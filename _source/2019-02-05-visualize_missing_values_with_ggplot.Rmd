---
layout: post
title: 'Missing values visualization'
categories:
  - data analysis
show_comments: true
tags: R, ggplot, dplyr, tidyverse, data vizualisation, data analysis, EDA
image: missing_values.jpg
output:
  md_document: default
  pdf_document:
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning=F, message=F)
```

```{r}
library(tidyverse)
library(gridExtra)
library(knitr)
```
```{r}
df <- read_csv('../_data/dataset.csv') %>% mutate(sales.rank=bsr) %>% 
  select(-X1, -currency, -bsr)
```

```{r}

missing.values.overview <- function(df) {
  grid.arrange(missing.values.pct(df), missing.values.rows(df), ncol = 2)
}

missing.values.rows <- function(df) {
  levels <-
    (df.missing.summary(df) %>% filter(isna == T) %>% arrange(desc(pct)))$key
  
  return(
    df %>%
      mutate(id = row_number()) %>%
      gather(-id, key = "key", value = "val") %>%
      mutate(isna = is.na(val)) %>%
      ggplot(aes(key, id, fill = isna)) +
      geom_raster(alpha=0.8) +
      scale_fill_manual(
        name = "",
        values = c('steelblue', 'tomato3'),
        labels = c("Present", "Missing")
      ) +
      scale_x_discrete(limits = levels) +
      theme_minimal() +
      theme(axis.text.x  = element_text(angle = 45, vjust = 0.5)) +
      labs(x = "Variable",
           y = "Row Number", title = "Missing values in rows") +
      coord_flip()
  )
}

missing.values.pct <- function(df) {
  summary.df <- df.missing.summary(df)
  
  return(
    summary.df %>%
      filter(isna == T) %>%
      ggplot() +
      geom_bar(aes(x = reorder(key, desc(
        pct
      )), y = pct), stat = 'identity', fill = 'tomato3', alpha=0.8) +
      theme_minimal() +
      coord_flip() +
      labs(title = "Percentage of missing values per variable", x =
             'Variable', y = "% of missing values")
  )
}
```


## A practical guide how to find and visualize missing data with tidyverse (ggplot2, dplyr, tidyr)

Finding missing values is an important task during the [Exploratory Data Analysis (EDA)](https://en.wikipedia.org/wiki/Exploratory_data_analysis). They can affect the quality of machine learning models and need to be cleaned before training models. This short practical guide will show you how to find missing values and visualize them with the help of the tidyverse ecosystem in R.


## The dataset

The dataset is scraped from a eCommerce website with product data. Evaluating the missing values has an interesting side effect in this case: The quality of the scraper can be evaluated with the number of missing values for the features. A feature with a lot of missing values might be a indicator for a problem with the extraction logic for that feature.

```{r echo=T, message=T}
df %>% head(10) %>% kable()
```

```{r show=T, message=T}
df %>% glimpse()
```


The dataset consists of 11 variables (2 qualitative and 9 quantitative) with 2172 rows.


## Table with missing values 
 
```{r}

df.missing.summary <- function(df) {
  summary <- df %>%
    gather(key = "key", value = "val") %>%
    mutate(isna = is.na(val)) %>%
    group_by(key) %>%
    mutate(total = n()) %>%
    group_by(key, total, isna) %>%
    summarise(num.isna = n()) %>%
    mutate(pct = num.isna / total * 100)
  
  return(summary)
}

```

You can count the values of missing values for each feature in the dataset:

```{r echo=T, message=T, fig.cap="Number of missing values for each variable"}
missing.values <- df %>%
    gather(key = "key", value = "val") %>%
    mutate(is.missing = is.na(val)) %>%
    group_by(key, is.missing) %>%
    summarise(num.missing = n()) %>%
    filter(is.missing==T) %>%
    select(-is.missing) %>%
    arrange(desc(num.missing))
    
missing.values %>% kable()
```

You can use the gather function from tidyr to collapse the columns into key-value pairs. Then you create a new logical feature which is true in case of a missing value. You group on the key and the new logical feature to do a count. Then you filter on the locical feature to get the count where the value is missing. You skip the rows which are not needed and sort by the number of missing values. 

## Visualize missing data


__Tables__ with their rows and columns  are read by our verbal system. This system is very slow. 
__Graphs__ interact with our visual system, which is much faster than the verbal system. This is the reason why in most cases you should use graphs instead of tables. 

You can visualize from above with a simple bar chart in ggplot2:

```{r message=T, echo=T}
missing.values %>%
  ggplot() +
    geom_bar(aes(x=key, y=num.missing), stat = 'identity') +
  labs(x='variable', y="number of missing values", title='Number of missing values per variable')
```

You can improve this graph by calculating the percentages of missing values for each feature. This is more meaningful. The visual appearance can be improved by swapping the axises to make the feature names readable. Sorting the bars by it's length is another improvement. Proper axis labeling is always a must. The use of the color red as visual cue for the missing values (=bad) is used as red stands for danger and that you have to act.


```{r}
missing.values <- df %>%
  gather(key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  group_by(key) %>%
  mutate(total = n()) %>%
  group_by(key, total, isna) %>%
  summarise(num.isna = n()) %>%
  mutate(pct = num.isna / total * 100)

missing.values %>%
      filter(isna == T) %>%
      ggplot() +
      geom_bar(aes(x = reorder(key, desc(
        pct
      )), y = pct), stat = 'identity', fill = 'tomato3', alpha=0.8) +
      theme_minimal() +
      coord_flip() +
      labs(title = "Percentage of missing values per variable", x =
             'Variable', y = "% of missing values")
```

You aggregate the data in a similar way like in the beginning, besides you are calculating percentages instead of abssolute count values. The data is then chained to the ggplot visualization part.

The plot shows you that you have problem in the scraping process with the features for product dimension (dim_x, dim_y, dim_z): Almost 100% of the values are missing. You can see that there is the same amount of missing values for sales.rank, sales and reviews.count. These values seem correlated with each other.

You can visualize the missing values in another way by plotting each row in the dataset. 

```{r fig.height=10, fig.width=20, message=T, echo=T}
levels <-
    (missing.values  %>% filter(isna == T) %>% arrange(desc(pct)))$key
  
df %>%
  mutate(id = row_number()) %>%
  gather(-id, key = "key", value = "val") %>%
  mutate(isna = is.na(val)) %>%
  ggplot(aes(key, id, fill = isna)) +
    geom_raster(alpha=0.8) +
    scale_fill_manual(
        name = "",
        values = c('steelblue', 'tomato3'),
        labels = c("Present", "Missing")
    ) +
    scale_x_discrete(limits = levels) +
    theme_minimal() +
    theme(axis.text.x  = element_text(angle = 45, vjust = 0.5)) +
    labs(x = "Variable",
           y = "Row Number", title = "Missing values in rows") +
    coord_flip()
  
```
This plot lets you find patterns which cannot be found with our bar chart. You can see links between missing values for different features.

The missing values for the features sales_rank and and sales are indeed linked to each other. This is what you expect. In the barchart you could see that also the reviews_count has about the same percentage of missing values. You would expect a linkage to sales and sales rank. Our second plot shows that there is no linkage.

You can put the two visualizations into one gridExtra package. 



```{r fig.height=10, fig.width=20}
missing.values.overview(df)
```


## Conclusion

You visualied missing values in data set in two ways. This you find weak points in the data scraper logic. 





